
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Supervised Learning without Neural Networks {#sec: linear methods for supervised learning} &#8212; Machine Learning for Sciences</title>
    
  <link rel="stylesheet" href="../_static/css/index.f658d18f9b420779cfdf24aa0a7e2d77.css">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    
      
  <link rel="stylesheet"
    href="../_static/vendor/open-sans_all/1.44.1/index.css">
  <link rel="stylesheet"
    href="../_static/vendor/lato_latin-ext/1.44.1/index.css">

    
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../_static/sphinx-book-theme.40e2e510f6b7d1648584402491bb10fe.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-main.c949a650a448cc0ae9fd3441c0e17fb0.css" />
    <link rel="stylesheet" type="text/css" href="../_static/panels-variables.06eb56fa6e07937060861dad626602ad.css" />
    
  <link rel="preload" as="script" href="../_static/js/index.d3f166471bb80abb5163.js">

    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/togglebutton.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script >var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/sphinx-book-theme.d31b09fe5c1d09cb49b26a786de4a05d.js"></script>
    <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    <script async="async" src="https://unpkg.com/thebelab@latest/lib/index.js"></script>
    <script >
        const thebe_selector = ".thebe"
        const thebe_selector_input = "pre"
        const thebe_selector_output = ".output"
    </script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Linear classifiers and their extensions" href="ml_without_neural_network-4.html" />
    <link rel="prev" title="Structuring Data without Neural Networks {#sec:structuring_data}" href="ml_without_neural_network-1.html" />

    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="en" />



  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="80">
    

    <div class="container-xl">
      <div class="row">
          
<div class="col-12 col-md-3 bd-sidebar site-navigation show" id="site-navigation">
    
        <div class="navbar-brand-box">
<a class="navbar-brand text-wrap" href="../index.html">
  
  <img src="../_static/cluster.png" class="logo" alt="logo">
  
  
  <h1 class="site-logo" id="site-title">Machine Learning for Sciences</h1>
  
</a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form>
<nav class="bd-links" id="bd-docs-nav" aria-label="Main navigation">
    <ul class="current nav sidenav_l1">
 <li class="toctree-l1">
  <a class="reference internal" href="introduction.html">
   Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ml_without_neural_network-1.html">
   Structuring Data without Neural Networks {#sec:structuring_data}
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   Supervised Learning without Neural Networks {#sec: linear methods for supervised learning}
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="ml_without_neural_network-4.html">
   Linear classifiers and their extensions
  </a>
 </li>
</ul>

</nav> <!-- To handle the deprecated key -->

<div class="navbar_extra_footer">
  Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
</div>

</div>


          


          
<main class="col py-md-3 pl-md-4 bd-content overflow-auto" role="main">
    
    <div class="row topbar fixed-top container-xl">
    <div class="col-12 col-md-3 bd-topbar-whitespace site-navigation show">
    </div>
    <div class="col pl-2 topbar-main">
        
        <button id="navbar-toggler" class="navbar-toggler ml-0" type="button" data-toggle="collapse"
            data-toggle="tooltip" data-placement="bottom" data-target=".site-navigation" aria-controls="navbar-menu"
            aria-expanded="true" aria-label="Toggle navigation" aria-controls="site-navigation"
            title="Toggle navigation" data-toggle="tooltip" data-placement="left">
            <i class="fas fa-bars"></i>
            <i class="fas fa-arrow-left"></i>
            <i class="fas fa-arrow-up"></i>
        </button>
        
        
<div class="dropdown-buttons-trigger">
    <button id="dropdown-buttons-trigger" class="btn btn-secondary topbarbtn" aria-label="Download this page"><i
            class="fas fa-download"></i></button>

    <div class="dropdown-buttons">
        <!-- ipynb file if we had a myst markdown file -->
        
        <!-- Download raw file -->
        <a class="dropdown-buttons" href="../_sources/docs/ml_without_neural_network-3.md"><button type="button"
                class="btn btn-secondary topbarbtn" title="Download source file" data-toggle="tooltip"
                data-placement="left">.md</button></a>
        <!-- Download PDF via print -->
        <button type="button" id="download-print" class="btn btn-secondary topbarbtn" title="Print to PDF"
            onClick="window.print()" data-toggle="tooltip" data-placement="left">.pdf</button>
    </div>
</div>

        <!-- Source interaction buttons -->


        <!-- Full screen (wrap in <a> to have style consistency -->
        <a class="full-screen-button"><button type="button" class="btn btn-secondary topbarbtn" data-toggle="tooltip"
                data-placement="bottom" onclick="toggleFullScreen()" aria-label="Fullscreen mode"
                title="Fullscreen mode"><i
                    class="fas fa-expand"></i></button></a>

        <!-- Launch buttons -->

    </div>

    <!-- Table of contents -->
    <div class="d-none d-md-block col-md-2 bd-toc show">
        
        <div class="tocsection onthispage pt-5 pb-3">
            <i class="fas fa-list"></i> Contents
        </div>
        <nav id="bd-toc-nav">
            <ul class="nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#linear-regression-sec-linear-regression">
   Linear regression {#sec:linear regression}
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#statistical-analysis">
     Statistical analysis
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#regularization-and-the-bias-variance-tradeoff">
     Regularization and the bias-variance tradeoff
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#example">
     Example
    </a>
   </li>
  </ul>
 </li>
</ul>

        </nav>
        
    </div>
</div>
    <div id="main-content" class="row">
        <div class="col-12 col-md-9 pl-md-3 pr-md-0">
        
              <div>
                
  <div class="section" id="supervised-learning-without-neural-networks-sec-linear-methods-for-supervised-learning">
<h1>Supervised Learning without Neural Networks {#sec: linear methods for supervised learning}<a class="headerlink" href="#supervised-learning-without-neural-networks-sec-linear-methods-for-supervised-learning" title="Permalink to this headline">¶</a></h1>
<p><em>Supervised learning</em> is the term for a machine learning task, where we
are given a dataset consisting of input-output pairs
<span class="math notranslate nohighlight">\(\lbrace({x}_{1}, y_{1}), \dots, ({x}_{m}, y_{m})\rbrace\)</span> and our
task is to “learn” a function which maps input to output
<span class="math notranslate nohighlight">\(f: {x} \mapsto y\)</span>. Here we chose a vector-valued input <span class="math notranslate nohighlight">\({x}\)</span> and
only a single real number as output <span class="math notranslate nohighlight">\(y\)</span>, but in principle also the
output can be vector valued. The output data that we have is called the
<em>ground truth</em> and sometimes also referred to as “labels” of the input.
In contrast to supervised learning, all algorithms presented so far were
unsupervised, because they just relied on input-data, without any ground
truth or output data.</p>
<p>Within the scope of supervised learning, there are two main types of
tasks: <em>Classification</em> and <em>Regression</em>. In a classification task, our
output <span class="math notranslate nohighlight">\(y\)</span> is a discrete variable corresponding to a classification
category. An example of such a task would be to distinguish stars with a
planetary system (exoplanets) from those without given time series of
images of such objects. On the other hand, in a regression problem, the
output <span class="math notranslate nohighlight">\(y\)</span> is a continuous number or vector. For example predicting the
quantity of rainfall based on meteorological data from the previous
days.</p>
<p>In this section, we first familiarize ourselves with linear methods for
achieving these tasks. Neural networks, in contrast, are a non-linear
method for supervised classification and regression tasks.</p>
<div class="section" id="linear-regression-sec-linear-regression">
<h2>Linear regression {#sec:linear regression}<a class="headerlink" href="#linear-regression-sec-linear-regression" title="Permalink to this headline">¶</a></h2>
<p>Linear regression, as the name suggests, simply means to fit a linear
model to a dataset. Consider a dataset consisting of input-output pairs
<span class="math notranslate nohighlight">\(\lbrace({x}_{1}, y_{1}), \dots, ({x}_{m}, y_{m})\rbrace\)</span>, where
the inputs are <span class="math notranslate nohighlight">\(n\)</span>-component vectors
<span class="math notranslate nohighlight">\(\boldsymbol{x}^{T} = (x_1, x_2, \dots , x_n)\)</span> and the output <span class="math notranslate nohighlight">\(y\)</span> is a
real-valued number. The linear model then takes the form
$<span class="math notranslate nohighlight">\(\label{eqn: Univariate Linear Model}
     f(\boldsymbol{x}|{\beta}) = \beta_0 + \sum_{j=1}^{n} \beta_{j}x_{j}\)</span><span class="math notranslate nohighlight">\(
or in matrix notation \)</span><span class="math notranslate nohighlight">\(\label{eqn: Univariate Linear Model Matrix Form}
    f(\boldsymbol{x}|{\beta}) = \tilde{{x}}^{T}{\beta}\)</span><span class="math notranslate nohighlight">\( where
\)</span>{\tilde{x}}^{T} = (1, x_1, x_2, \dots , x_n)<span class="math notranslate nohighlight">\( and
\)</span>{\beta} = (\beta_0, \dots, \beta_n)^{T}<span class="math notranslate nohighlight">\( are \)</span>(n+1)<span class="math notranslate nohighlight">\( dimensional row
vectors. The aim then is to find parameters \)</span>\hat{{\beta}}<span class="math notranslate nohighlight">\( such that
\)</span>f({x}|\hat{{\beta}})<span class="math notranslate nohighlight">\( is a good *estimator* for the output value
\)</span>y<span class="math notranslate nohighlight">\(. In order to quantify what it means to be a “good” estimator, one
need to specify a real-valued *loss function* \)</span>L({\beta})<span class="math notranslate nohighlight">\(, sometimes
also called a *cost function*. The good set of parameters
\)</span>\hat{{\beta}}<span class="math notranslate nohighlight">\( is then the minimizer of this loss function
\)</span><span class="math notranslate nohighlight">\(\hat{{\beta}} = \mathop{\mathrm{argmin}}_{{\beta}} L({\beta}).\)</span><span class="math notranslate nohighlight">\(
There are many, inequivalent, choices for this loss function. For our
purpose, we choose the loss function to be *residual sum of squares*
(RSS) defined as \)</span><span class="math notranslate nohighlight">\(\label{eqn: RSS}
\begin{split}
    \textrm{RSS}({\beta}) &amp;= \sum_{i=1}^{m} [y_{i} -  f({x}_{i}|{\beta})]^{2} \\
    &amp;= \sum_{i=1}^{m} \left(y_{i} -  \beta_0 -\sum_{j=1}^{n} \beta_{j}x_{ij}\right)^{2},
\end{split}\)</span><span class="math notranslate nohighlight">\( where the sum runs over the \)</span>m<span class="math notranslate nohighlight">\( samples of the dataset.
This loss function is sometimes also called the *L2-loss* and can be
seen as a measure of the distance between the output values from the
dataset \)</span>y_i<span class="math notranslate nohighlight">\( and the corresponding predictions
\)</span>f({x}_i|{\beta})$.</p>
<p>It is convenient to define the <span class="math notranslate nohighlight">\(m\)</span> by <span class="math notranslate nohighlight">\((n+1)\)</span> data matrix
<span class="math notranslate nohighlight">\(\widetilde{X}\)</span>, each row of which corresponds to an input sample
<span class="math notranslate nohighlight">\({\tilde{x}}^{T}_{i}\)</span>, as well as the output vector
<span class="math notranslate nohighlight">\({Y}^{T} = (y_{1}, \dots, y_{m})\)</span>. With this notation, Eq.  can be
expressed succinctly as a matrix equation
$<span class="math notranslate nohighlight">\(\textrm{RSS}({\beta}) = ({Y} - \widetilde{X}{\beta})^{T}({Y} - \widetilde{X}{\beta}).\)</span><span class="math notranslate nohighlight">\(
The minimum of \)</span>\textrm{RSS}({\beta})<span class="math notranslate nohighlight">\( can be easily solved by
considering the partial derivatives with respect to \)</span>{\beta}<span class="math notranslate nohighlight">\(, i.e.,
\)</span><span class="math notranslate nohighlight">\(\begin{split}
  &amp;\frac{\partial \textrm{RSS}}{\partial {\beta}} = -2 \widetilde{X}^{T}({Y} - \widetilde{X}{\beta}), \\
  &amp;\frac{\partial^{2} \textrm{RSS}}{\partial {\beta}\partial {\beta}^{T}} = 2 \widetilde{X}^{T}\widetilde{X}.
\end{split}\)</span><span class="math notranslate nohighlight">\( At the minimum,
\)</span>\frac{\partial \textrm{RSS}}{\partial {\beta}} = 0<span class="math notranslate nohighlight">\( and
\)</span>\frac{\partial^{2} \textrm{RSS}}{\partial {\beta}\partial {\beta}^{T}}<span class="math notranslate nohighlight">\(
is positive-definite. Assuming \)</span> \widetilde{X}^{T}\widetilde{X}<span class="math notranslate nohighlight">\( is
full-rank and hence invertible, we can obtain the solution
\)</span>\hat{{\beta}}<span class="math notranslate nohighlight">\( as \)</span><span class="math notranslate nohighlight">\(\label{eqn: LG RSS Solution}
\begin{split}
    &amp;\left.\frac{\partial \textrm{RSS}}{\partial {\beta}}\right|_{{\beta}=\hat{{\beta}}} = 0, \\
      \implies &amp;\widetilde{X}^{T}\widetilde{X}\hat{{\beta}} = \widetilde{X}^{T}{Y}, \\
    \implies
 &amp; \hat{{\beta} }=  (\widetilde{X}^{T}\widetilde{X})^{-1} \widetilde{X}^{T} {Y}.
\end{split}\)</span><span class="math notranslate nohighlight">\( If \)</span> \widetilde{X}^{T}\widetilde{X}<span class="math notranslate nohighlight">\( is not full-rank,
which can happen if certain data features are perfectly correlated
(e.g., \)</span>x_1 = 2x_3<span class="math notranslate nohighlight">\(), the solution to
\)</span>\widetilde{X}^{T}\widetilde{X}{\beta} = \widetilde{X}^{T}{Y}$ can
still be found, but it would not be unique. Note that the RSS is not the
only possible choice for the loss function and a different choice would
lead to a different solution.</p>
<p>What we have done so far is uni-variate linear regression, that is
linear regression where the output <span class="math notranslate nohighlight">\(y\)</span> is a single real-valued number.
The generalisation to the multi-variate case, where the output is a
<span class="math notranslate nohighlight">\(p\)</span>-component vector <span class="math notranslate nohighlight">\({y}^{T} = (y_1, \dots y_p)\)</span>, is
straightforward. The model takes the form
$<span class="math notranslate nohighlight">\(\label{eqn: Multivariate Linear Model}
    f_{k}({x}|\beta) = \beta_{0k} + \sum_{j=1}^{n} \beta_{jk}x_{j}.\)</span><span class="math notranslate nohighlight">\(
where the parameters \)</span>\beta_{jk}<span class="math notranslate nohighlight">\( now have an additional index
\)</span>k = 1, \dots, p<span class="math notranslate nohighlight">\(. Considering the parameters \)</span>\beta<span class="math notranslate nohighlight">\( as a \)</span>(n+1)<span class="math notranslate nohighlight">\( by
\)</span>p<span class="math notranslate nohighlight">\( matrix, we can show that the solution takes the same form as before
\[Eq. \] with \)</span>Y<span class="math notranslate nohighlight">\( as a \)</span>m<span class="math notranslate nohighlight">\( by \)</span>p$ output matrix.</p>
<div class="section" id="statistical-analysis">
<h3>Statistical analysis<a class="headerlink" href="#statistical-analysis" title="Permalink to this headline">¶</a></h3>
<p>Let us stop here and evaluate the quality of the method we have just
introduced. At the same time, we will take the opportunity to introduce
some statistics notions, which will be useful throughout the book.</p>
<p>Up to now, we have made no assumptions about the dataset we are given,
we simply stated that it consisted of input-output pairs,
<span class="math notranslate nohighlight">\(\{({x}_{1}, y_{1}), \dots,\)</span> <span class="math notranslate nohighlight">\(({x}_{m}, y_{m})\}\)</span>. In order to
assess the accuracy of our model in a mathematically clean way, we have
to make an additional assumption. The output data <span class="math notranslate nohighlight">\(y_1\ldots, y_m\)</span> may
arise from some measurement or observation. Then, each of these values
will generically be subject to errors <span class="math notranslate nohighlight">\(\epsilon_1,\cdots, \epsilon_m\)</span> by
which the values deviate from the “true” output without errors,
$<span class="math notranslate nohighlight">\(\label{eqn: True Linear_b}
\begin{split}
        y_i &amp;= y^{\textrm{true}}_i + \epsilon_i,\qquad i=1,\cdots,m.
\end{split}\)</span><span class="math notranslate nohighlight">\( We assume that this error \)</span>\epsilon<span class="math notranslate nohighlight">\( is a Gaussian random
variable with mean \)</span>\mu = 0<span class="math notranslate nohighlight">\( and variance \)</span>\sigma^2<span class="math notranslate nohighlight">\(, which we denote by
\)</span>\epsilon \sim \mathcal{N}(0, \sigma^2)<span class="math notranslate nohighlight">\(. Assuming that a linear model
in Eq.  is a suitable model for our dataset, we are interested in the
following question: How does our solution \)</span>\hat{{\beta}}<span class="math notranslate nohighlight">\( as given in
Eq.  compare with the true solution \)</span>{\beta}^{\textrm{true}}<span class="math notranslate nohighlight">\( which
obeys \)</span><span class="math notranslate nohighlight">\(\label{eqn: True Linear}
\begin{split}
        y_i = \beta_0^{\textrm{true}} + \sum_{j=1}^{n} \beta_{j}^{\textrm{true}}x_{ij} + \epsilon_i,\qquad
        i=1,\ldots,m?
\end{split}\)</span>$</p>
<p>In order to make statistical statements about this question, we have to
imagine that we can fix the inputs <span class="math notranslate nohighlight">\({x}_{i}\)</span> of our dataset and
repeatedly draw samples for our outputs <span class="math notranslate nohighlight">\(y_i\)</span>. Each time we will obtain
a different value for <span class="math notranslate nohighlight">\(y_i\)</span> following Eq. , in other words the
<span class="math notranslate nohighlight">\(\epsilon_i\)</span> are uncorrelated random numbers. This allows us to
formalise the notion of an <em>expectation value</em> <span class="math notranslate nohighlight">\(E(\cdots)\)</span> as the
average over an infinite number of draws. For each draw, we obtain a new
dataset, which differs from the other ones by the values of the outputs
<span class="math notranslate nohighlight">\(y_i\)</span>. With each of these datasets, we obtain a different solution
<span class="math notranslate nohighlight">\(\hat{{\beta}}\)</span> as given by Eq. . The expectation value
<span class="math notranslate nohighlight">\(E(\hat{{\beta}})\)</span> is then simply the average value we obtained
across an infinite number of datasets. The deviation of this average
value from the “true” value given perfect data is called the <em>bias</em> of
the model, $<span class="math notranslate nohighlight">\(\label{eqn: Bias}
    \textrm{Bias}(\hat{{\beta}}) = E(\hat{{\beta}})-{\beta}^{\textrm{true}}.\)</span><span class="math notranslate nohighlight">\(
For the linear regression we study here, the bias is exactly zero,
because \)</span><span class="math notranslate nohighlight">\(\label{eqn: LG RSS Unbiased}
    \begin{split}
      E(\hat{{\beta}}) &amp;= E\left((\widetilde{X}^{T}\widetilde{X})^{-1} \widetilde{X}^{T} ({Y}^{\textrm{true}}+{\epsilon})\right)\\
      &amp;={\beta}^{\textrm{true}},
    \end{split}\)</span><span class="math notranslate nohighlight">\( where the second line follows because
\)</span>E({\epsilon}) = {0}<span class="math notranslate nohighlight">\( and
\)</span>(\widetilde{X}^{T}\widetilde{X})^{-1} \widetilde{X}^{T} {Y}^{\textrm{true}} = {\beta}^{\textrm{true}}$.
Equation  implies linear regression is unbiased. Note that other machine
learning algorithms will in general be biased.</p>
<p>What about the standard error or uncertainty of our solution? This
information is contained in the <em>covariance matrix</em> $<span class="math notranslate nohighlight">\(\begin{split}
    \textrm{Var}(\hat{{\beta}}) &amp;= E\left([\hat{{\beta}} - E(\hat{{\beta}})][\hat{{\beta}} - E(\hat{{\beta}})]^{T} \right).
\end{split}\)</span><span class="math notranslate nohighlight">\( The covariance matrix can be computed for the case of
linear regression using the solution in Eq. , the expectation value in
Eq.  and the assumption in Eq.  that
\)</span>Y = Y^{\textrm{true}} + {\epsilon}<span class="math notranslate nohighlight">\( yielding \)</span><span class="math notranslate nohighlight">\(\begin{split}
    \textrm{Var}(\hat{{\beta}}) &amp;= E\left([\hat{{\beta}} - E(\hat{{\beta}})][\hat{{\beta}} - E(\hat{{\beta}})]^{T} \right)\\
     &amp;= E\left( \left[ (\widetilde{X}^{T}\widetilde{X})^{-1} \widetilde{X}^{T} {\epsilon} \right] \left[ (\widetilde{X}^{T}\widetilde{X})^{-1} \widetilde{X}^{T} {\epsilon}\right]^{T} \right) \\
    &amp;= E\left( (\widetilde{X}^{T}\widetilde{X})^{-1} \widetilde{X}^{T} {\epsilon} {\epsilon}^{T} \widetilde{X} (\widetilde{X}^{T}\widetilde{X})^{-1}  \right).
\end{split}\)</span><span class="math notranslate nohighlight">\( This expression can be simplified by using the fact that
our input matrices \)</span>\widetilde{X}<span class="math notranslate nohighlight">\( are independent of the draw such that
\)</span><span class="math notranslate nohighlight">\(\begin{split}
\textrm{Var}(\hat{{\beta}})
    &amp;= (\widetilde{X}^{T}\widetilde{X})^{-1} \widetilde{X}^{T} E({\epsilon} {\epsilon}^{T}) \widetilde{X} (\widetilde{X}^{T}\widetilde{X})^{-1} \\
    &amp;= (\widetilde{X}^{T}\widetilde{X})^{-1} \widetilde{X}^{T} \sigma^2 I \widetilde{X} (\widetilde{X}^{T}\widetilde{X})^{-1} \\
    &amp;= \sigma^2 (\widetilde{X}^{T}\widetilde{X})^{-1}.
\end{split}\)</span><span class="math notranslate nohighlight">\( Here, the second line follows from the fact that different
samples are uncorrelated, which implies that
\)</span>E({\epsilon} {\epsilon}^{T}) = \sigma^2 I<span class="math notranslate nohighlight">\( with \)</span>I<span class="math notranslate nohighlight">\( the identity
matrix. The diagonal elements of
\)</span>\sigma^2 (\widetilde{X}^{T}\widetilde{X})^{-1}<span class="math notranslate nohighlight">\( then correspond to the
variance \)</span><span class="math notranslate nohighlight">\(\begin{split}
    \textrm{Var}(\hat{{\beta}}) &amp;= E\left([\hat{{\beta}} - E(\hat{{\beta}})][\hat{{\beta}} - E(\hat{{\beta}})]^{T} \right)\\
     &amp;= \sigma^2 (\widetilde{X}^{T}\widetilde{X})^{-1}.
\end{split}\)</span><span class="math notranslate nohighlight">\( of the individual parameters \)</span>\beta_i<span class="math notranslate nohighlight">\(. The standard error
or uncertainty is then \)</span>\sqrt{\textrm{Var}(\hat{\beta}_{i})}$.</p>
<p>There is one more missing element: we have not explained how to obtain
the variances <span class="math notranslate nohighlight">\(\sigma^2\)</span> of the outputs <span class="math notranslate nohighlight">\(y\)</span>. In an actual machine
learning task, we would not know anything about the true relation, as
given in Eq. , governing our dataset. The only information we have
access to is a single dataset. Therefore, we have to estimate the
variance using the samples in our dataset, which is given by
$<span class="math notranslate nohighlight">\(\hat{\sigma}^2 = \frac{1}{m - n - 1}\sum_{i=1}^{m} (y_{i} - f({x}_i|\hat{{\beta}}))^2,\)</span><span class="math notranslate nohighlight">\(
where \)</span>y_i<span class="math notranslate nohighlight">\( are the output values from our dataset and
\)</span>f({x}_i|\hat{{\beta}})<span class="math notranslate nohighlight">\( is the corresponding prediction. Note
that we normalized the above expression by \)</span>(m - n - 1)<span class="math notranslate nohighlight">\( instead of \)</span>m<span class="math notranslate nohighlight">\(
to ensure that \)</span>E(\hat{\sigma}^2) = \sigma^2<span class="math notranslate nohighlight">\(, meaning that
\)</span>\hat{\sigma}^2<span class="math notranslate nohighlight">\( is an unbiased estimator of \)</span>\sigma^2$.</p>
<p>Our ultimate goal is not simply to fit a model to the dataset. We want
our model to generalize to inputs not within the dataset. To assess how
well this is achieved, let us consider the prediction
<span class="math notranslate nohighlight">\(\tilde{{a}}^{T} \hat{{\beta}}\)</span> on a new random input-output pair
<span class="math notranslate nohighlight">\(({a},y_{0})\)</span>. The output is again subject to an error
<span class="math notranslate nohighlight">\(y_{0} = \tilde{{a}}^{T}{\beta}^{\textrm{true}} + \epsilon\)</span>. In
order to compute the expected error of the prediction, we compute the
expectation value of the loss function over these previously unseen
data. This is also known as the <em>test or generalization error</em> . For the
square-distance loss function, this is the <em>mean square error</em> (MSE)
$<span class="math notranslate nohighlight">\(\label{eqn: MSE Generalisation Error}
    \begin{split}
        \textrm{MSE}(\hat{{\beta}}) =&amp;E\left((y_{0} - \tilde{{a}}^{T} \hat{{\beta}})^2\right) \\
        = &amp;E\left((\epsilon + \tilde{{a}}^{T}{\beta}^{\textrm{true}} - \tilde{{a}}^{T}\hat{{\beta}})^2\right) \\
        = &amp;E(\epsilon^2) +  [\tilde{{a}}^{T}({\beta}^{\textrm{true}} - E(\hat{{\beta}}))]^2 + E\left( [\tilde{{a}}^{T}(\hat{{\beta}} - E(\hat{{\beta}}))]^2\right) \\
        = &amp;\sigma^2 + [\tilde{{a}}^{T}\textrm{Bias}(\hat{{\beta}})]^2 + \tilde{{a}}^{T} \textrm{Var}(\hat{{\beta}}) \tilde{{a}}.
    \end{split}\)</span><span class="math notranslate nohighlight">\( There are three terms in the expression. The first
term is the irreducible or intrinsic uncertainty of the dataset. The
second term represents the bias and the third term is the variance of
the model. For RSS linear regression, the estimate is unbiased so that
\)</span><span class="math notranslate nohighlight">\(%E\left((y_{0} - {a}^{T} \hat{{\beta}})^2\right) &amp;= \sigma^2 +  E\left( [{a}^{T}(\hat{{\beta}} - E(\hat{{\beta}}))]^2\right)\\
        \textrm{MSE}(\hat{{\beta}}) = \sigma^2 + \tilde{{a}}^{T} \textrm{Var}(\hat{{\beta}}) \tilde{{a}}.\)</span>$
Based on the assumption that the dataset indeed derives from a linear
model as given by Eq.  with a Gaussian error, it can be shown that the
RSS solution, Eq. , gives the minimum error among all unbiased linear
estimators, Eq. . This is known as the Gauss-Markov theorem.</p>
<p>This completes our error analysis of the method.</p>
</div>
<div class="section" id="regularization-and-the-bias-variance-tradeoff">
<h3>Regularization and the bias-variance tradeoff<a class="headerlink" href="#regularization-and-the-bias-variance-tradeoff" title="Permalink to this headline">¶</a></h3>
<p>Although the RSS solution has the minimum error among unbiased linear
estimators, the expression for the generalisation error, Eq. , suggests
that we can actually still reduce the error by sacrificing some bias in
our estimate.</p>
<p><img alt="Schematic depiction of the bias-variance tradeoff.[]{data-label=&quot;fig: Bias-Variance Tradeoff&quot;}" src="docs/figures/Bias-Variance-Tradeoff.pdf" />{width=”50.00000%”}</p>
<p>A possible way to reduce generalisation error is actually to drop some
data features. From the <span class="math notranslate nohighlight">\(n\)</span> data features
<span class="math notranslate nohighlight">\(\lbrace x_{1}, \dots x_{n} \rbrace\)</span>, we can pick a reduced set
<span class="math notranslate nohighlight">\(\mathcal{M}\)</span>. For example, we can choose
<span class="math notranslate nohighlight">\(\mathcal{M} = \lbrace x_{1}, x_{3}, x_{7} \rbrace\)</span>, and define our new
linear model as $<span class="math notranslate nohighlight">\(\label{eqn: Univariate Subset Linear Model}
    f(\boldsymbol{x}|{\beta}) = \beta_0 + \sum_{j \in \mathcal{M}} \beta_{j}x_{j}.\)</span><span class="math notranslate nohighlight">\(
This is equivalent to fixing some parameters to zero, i.e.,
\)</span>\beta_k = 0<span class="math notranslate nohighlight">\( if \)</span>x_{k} \notin \mathcal{M}<span class="math notranslate nohighlight">\(. Minimizing the RSS with
this constraint results in a biased estimator but the reduction in model
variance can sometimes help to reduce the overall generalisation error.
For a small number of features \)</span>n \sim 20$, one can search exhaustively
for the best subset of features that minimises the error, but beyond
that the search becomes computationally unfeasible.</p>
<p>A common alternative is called <em>ridge regression</em>. In this method, we
consider the same linear model given in Eq.  but with a modified loss
function $$\label{eqn: Ridge}</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>L_{\textrm{ridge}}({\beta}) = \sum_{i=1}^{m} \left[y_{i} -   f(\boldsymbol{x}_i|{\beta})\right]^{2} + \lambda \sum_{j=0}^{n} \beta_{j}^{2},$$
</pre></div>
</div>
<p>where <span class="math notranslate nohighlight">\(\lambda &gt; 0\)</span> is a positive parameter. This is almost the same as
the RSS apart from the term proportional to <span class="math notranslate nohighlight">\(\lambda\)</span> [c.f. Eq. ]. The
effect of this new term is to penalize large parameters <span class="math notranslate nohighlight">\(\beta_j\)</span> and
bias the model towards smaller absolute values. The parameter <span class="math notranslate nohighlight">\(\lambda\)</span>
is an example of a <em>hyper-parameter</em>, which is kept fixed during the
training. On fixing <span class="math notranslate nohighlight">\(\lambda\)</span> and minimising the loss function, we
obtain the solution $<span class="math notranslate nohighlight">\(\label{eqn: Ridge Solution}
    \hat{{\beta}}_{\textrm{ridge}} = (\widetilde{X}^{T}\widetilde{X} + \lambda I)^{-1}\widetilde{X}^{T}{Y},\)</span><span class="math notranslate nohighlight">\(
from which we can see that as \)</span>\lambda \rightarrow \infty<span class="math notranslate nohighlight">\(,
\)</span>\hat{{\beta}}_{\textrm{ridge}} \rightarrow {0}<span class="math notranslate nohighlight">\(. By computing the
bias and variance, \)</span><span class="math notranslate nohighlight">\(\label{eqn: Ridge Bias-Variance}
    \begin{split}
        \textrm{Bias}(\hat{{\beta}}_{\textrm{ridge}}) &amp;= -\lambda (\widetilde{X}^{T}\widetilde{X} + \lambda I)^{-1} {\beta}^{\textrm{true}}\\
        \textrm{Var}(\hat{{\beta}}_{\textrm{ridge}}) &amp;= \sigma^2 (\widetilde{X}^{T}\widetilde{X} + \lambda I)^{-1} \widetilde{X}^{T}\widetilde{X}(\widetilde{X}^{T}\widetilde{X} + \lambda I)^{-1},
    \end{split}\)</span><span class="math notranslate nohighlight">\( it is also obvious that increasing \)</span>\lambda<span class="math notranslate nohighlight">\( increases
the bias, while reducing the variance. This is the tradeoff between bias
and variance. By appropriately choosing \)</span>\lambda<span class="math notranslate nohighlight">\( it is possible that
generalisation error can be reduced. We will introduce in the next
section a common strategy how to find the optimal value for \)</span>\lambda$.</p>
<p>The techniques presented here to reduce the generalization error, namely
dropping of features and biasing the model to small parameters, are part
of a large class of methods known as <em>regularization</em>. Comparing the two
methods, we can see a similarity. Both methods actually reduce the
complexity of our model. In the former, some parameters are set to zero,
while in the latter, there is a constraint which effectively reduces the
magnitude of all parameters. A less complex model has a smaller variance
but larger bias. By balancing these competing effects, generalisation
can be improved, as illustrated schematically in Fig. [fig:
Bias-Variance Tradeoff].</p>
<p>In the next chapter, we will see that these techniques are useful beyond
applications to linear methods. We illustrate the different concepts in
the following example.</p>
<p><img alt="Machine LearningWorkflow.[]{data-label=&quot;fig: ML Workflow&quot;}" src="docs/figures/ML_Workflow.pdf" />{width=”70.00000%”}</p>
</div>
<div class="section" id="example">
<h3>Example<a class="headerlink" href="#example" title="Permalink to this headline">¶</a></h3>
<p>We illustrate the concepts of linear regression using a medical dataset.
In the process, we will also familiarize ourselves with the standard
machine learning workflow [see Fig. [fig: ML Workflow]]. For this
example, we are given <span class="math notranslate nohighlight">\(10\)</span> data features, namely age, sex, body mass
index, average blood pressure, and six blood serum measurements from
<span class="math notranslate nohighlight">\(442\)</span> diabetes patients, and our task is train a model
<span class="math notranslate nohighlight">\(f({x}|{\beta})\)</span> [Eq. ] to predict a quantitative measure of the
disease progression after one year.</p>
<p>Recall that the final aim of a machine-learning task is not to obtain
the smallest possible value for the loss function such as the RSS, but
to minimise the generalisation error on unseen data [c.f. Eq. ]. The
standard approach relies on a division of the dataset into three
subsets: training set, validation set and test set. The standard
workflow is summarised in Box [box: ML Workflow].</p>
<p>[box: ML Workflow]{}</p>
<ol class="simple">
<li><p>Divide the dataset into training set <span class="math notranslate nohighlight">\(\mathcal{T}\)</span>, validation set
<span class="math notranslate nohighlight">\(\mathcal{V}\)</span> and test set <span class="math notranslate nohighlight">\(\mathcal{S}\)</span>. A common ratio for the
split is <span class="math notranslate nohighlight">\(70 : 15 : 15\)</span>.</p></li>
<li><p>Pick the hyperparameters, e.g., <span class="math notranslate nohighlight">\(\lambda\)</span> in Eq. .</p></li>
<li><p>Train the model with only the training set, in other words minimize
the loss function on the training set. [This corresponds to Eq.  or
for the linear regression, where <span class="math notranslate nohighlight">\(\widetilde{X}\)</span> only contains the
training set.]</p></li>
<li><p>Evaluate the MSE (or any other chosen metric) on the validation set,
[c.f. Eq. ]
$<span class="math notranslate nohighlight">\(\textrm{MSE}_{\textrm{validation}}(\hat{{\beta}}) = \frac{1}{|\mathcal{V}|}\sum_{j\in\mathcal{V}} (y_j - f({x}_j|\hat{{\beta}}))^2.\)</span>$
This is known as the <em>validation error</em>.</p></li>
<li><p>Pick a different value for the hyperparameters and repeat steps <span class="math notranslate nohighlight">\(3\)</span>
and <span class="math notranslate nohighlight">\(4\)</span>, until validation error is minimized.</p></li>
<li><p>Evaluate the final model on the test set
$<span class="math notranslate nohighlight">\(\textrm{MSE}_{\textrm{test}}(\hat{{\beta}}) = \frac{1}{|\mathcal{S}|}\sum_{j\in\mathcal{S}} (y_j - f({x}_j|\hat{{\beta}}))^2.\)</span>$</p></li>
</ol>
<p>It is important to note that the test set <span class="math notranslate nohighlight">\(\mathcal{S}\)</span> was not involved
in optimizing either parameters <span class="math notranslate nohighlight">\({\beta}\)</span> or the hyperparameters such
as <span class="math notranslate nohighlight">\(\lambda\)</span>.</p>
<p>Applying this procedure to the diabetes dataset<a class="footnote-reference brackets" href="#id2" id="id1">2</a>, we obtain the
results in Fig. [fig: Regression on Diabetes Dataset]. We compare RSS
linear regression with the ridge regression, and indeed we see that by
appropriately choosing the regularisation hyperparameter <span class="math notranslate nohighlight">\(\lambda\)</span>, the
generalisation error can be minimized.</p>
<p>As side remark regarding the ridge regression, we can see on the left of
Fig. [fig: Ridge Parameters], that as <span class="math notranslate nohighlight">\(\lambda\)</span> increases, the
magnitude of the parameters, Eq. , <span class="math notranslate nohighlight">\(\hat{{\beta}}_{\textrm{ridge}}\)</span>
decreases. Consider on the other hand, a different form of
regularisation, which goes by the name <em>lasso regression</em>, where the
loss function is given by $<span class="math notranslate nohighlight">\(\label{eqn: Lasso}
    %L_{\textrm{lasso}}({\beta}) = \sum_{i=1}^{m} \left(y_{i} -  \beta_0 +\sum_{j=1}^{n} \beta_{j}x_{ij}\right)^{2} + \alpha \sum_{j=0}^{n} |\beta_{j}|.
    L_{\textrm{lasso}}({\beta}) = \sum_{i=1}^{m} \left[y_{i} -  f(\boldsymbol{x}_i|{\beta})\right]^{2} + \alpha \sum_{j=0}^{n} |\beta_{j}|.\)</span><span class="math notranslate nohighlight">\(
Despite the similarities, lasso regression has a very different
behaviour as depicted on the right of Fig. \[fig: Ridge Parameters\].
Notice that as \)</span>\alpha$ increases some parameters actually vanish and
can be ignored completely. This actually corresponds to dropping certain
data features completely and can be useful if we are interested in
selecting the most important features in a dataset.</p>
<p><img alt="Ridge Regression on Diabetes patients dataset. Left: Validationerror versus . Right: Test data versus the prediction from thetrained model. If the prediction were free of any error, all the pointswould fall on the blue line.[]{data-label=&quot;fig: Regression on Diabetes Dataset&quot;}" src="docs/figures/diabetes_ridge_regression.pdf" />{width=”100.00000%”}</p>
<p><img alt=" Evolution of the model parameters. Increasing the hyperparameter or  leads to a reduction of the absolute value of themodel parameters, here shown for the ridge (left) and Lasso (right)regression for the Diabetes dataset.[]{data-label=&quot;fig: Ridge Parameters&quot;}" src="docs/figures/ridge_variables.pdf" />{width=”100.00000%”}</p>
<hr class="docutils" />
<dl class="footnote brackets">
<dt class="label" id="id2"><span class="brackets"><a class="fn-backref" href="#id1">2</a></span></dt>
<dd><p>Source:
<a class="reference external" href="https://www4.stat.ncsu.edu/%7Eboos/var.select/diabetes.html">https://www4.stat.ncsu.edu/<span class="math notranslate nohighlight">\(\small{\sim}\)</span>boos/var.select/diabetes.html</a></p>
</dd>
</dl>
</div>
</div>
</div>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./docs"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
        </div>
    </div>
    
    
    <div class='prev-next-bottom'>
        
    <a class='left-prev' id="prev-link" href="ml_without_neural_network-1.html" title="previous page">Structuring Data without Neural Networks {#sec:structuring_data}</a>
    <a class='right-next' id="next-link" href="ml_without_neural_network-4.html" title="next page">Linear classifiers and their extensions</a>

    </div>
    <footer class="footer mt-5 mt-md-0">
    <div class="container">
      <p>
        
          By Eliska<br/>
        
            &copy; Copyright 2020.<br/>
      </p>
    </div>
  </footer>
</main>


      </div>
    </div>

    
  <script src="../_static/js/index.d3f166471bb80abb5163.js"></script>


    
  </body>
</html>